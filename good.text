let words = [];
let allPixels = [];
let currentInput = "";
let inputX, inputY;
let isTyping = false;
let cursorBlink = false;
let lastBlinkTime = 0;
let blinkInterval = 500; // milliseconds

let fonts = [];
let fontNames = ['Old']; // Add more fonts if needed

let disintegrationColors = [
    { r: 0, g: 0, b: 255 }, // Blue
    { r: 255, g: 165, b: 0 }, // Orange
    { r: 128, g: 128, b: 128 }, // Grey
    { r: 0, g: 128, b: 0 } // Green
];

function preload() {
    // Load fonts from assets directory
    for (let fontName of fontNames) {
        fonts.push(loadFont(`${fontName}.ttf`)); // Ensure these fonts are available in the assets folder
    }
}

function setup() {
    noCursor();
    createCanvas(windowWidth, windowHeight);

    // Allow users to add words by clicking
    canvas.addEventListener('click', (event) => {
        inputX = event.clientX;
        inputY = event.clientY;
        currentInput = "";
        isTyping = true;
    });

    // Listen for keyboard events
    window.addEventListener('keydown', (event) => {
        if (isTyping) {
            if (event.key === 'Enter') {
                let randomFont = random(fonts);
                let randomFontSize = random(64, 72);
                let newWord = new PixelizedWord(currentInput, inputX, inputY, randomFont, randomFontSize);
                words.push(newWord);
                allPixels = allPixels.concat(newWord.pixels);
                isTyping = false;
            } else if (event.key === 'Backspace') {
                currentInput = currentInput.slice(0, -1);
            } else if (event.key.length === 1) {
                currentInput += event.key;
            }
        }
    });
}

function draw() {
    background(255);
    drawWindows98Frame();

    for (let word of words) {
        word.update();
    }

    updatePixelsGlobal();

    if (isTyping) {
        fill(0);
        textFont(fonts[0]); // Use the first font as default for typing input
        textSize(64);
        text(currentInput, inputX, inputY);

        // Display text insertion cursor
        let textWidthSoFar = textWidth(currentInput);
        let cursorX = inputX + textWidthSoFar;

        // Blink logic
        if (millis() - lastBlinkTime > blinkInterval) {
            cursorBlink = !cursorBlink;
            lastBlinkTime = millis();
        }
        if (cursorBlink) {
            stroke(0);
            line(cursorX, inputY - textSize() * 0.75, cursorX, inputY + textSize() * 0.25); // Adjust vertical position based on text size
        }
    }

    // Display floating cursor
    fill(255, 0, 0);
    ellipse(mouseX, mouseY, 25, 25); // Floating cursor as a small circle

    // Grow vines
    growVines();
}

function updatePixelsGlobal() {
    for (let pixel of allPixels) {
        if (pixel.falling) {
            pixel.y += pixel.size / 2; // Fall speed

            // Stop falling when reaching the bottom or colliding with another pixel
            if (pixel.y >= height - pixel.size || isCollidingGlobal(pixel)) {
                pixel.y = min(pixel.y, height - pixel.size);
                pixel.falling = false;
            }
        }
    }

    for (let pixel of allPixels) {
        fill(pixel.r, pixel.g, pixel.b, pixel.a);
        noStroke();
        rect(pixel.x, pixel.y, pixel.size, pixel.size);
    }
}

function isCollidingGlobal(pixel) {
    for (let other of allPixels) {
        if (other !== pixel && !other.falling && dist(pixel.x, pixel.y, other.x, other.y) < pixel.size) {
            return true;
        }
    }
    return false;
}

function growVines() {
    for (let i = 0; i < allPixels.length; i++) {
        let pixel = allPixels[i];
        if (!pixel.falling && pixel.y >= height - pixel.size) {
            for (let j = 0; j < allPixels.length; j++) {
                let other = allPixels[j];
                if (other !== pixel && !other.falling && other.y >= height - other.size && dist(pixel.x, pixel.y, other.x, other.y) < pixel.size) {
                    // Grow curly green vines
                    growCurlyVines(pixel.x, pixel.y);
                }
            }
        }
    }
}

function growCurlyVines(x, y) {
    stroke(0, 128, 0);
    noFill();
    beginShape();
    let noiseScale = 0.1;
    for (let i = 0; i < 100; i++) {
        let nx = x + noise(i * noiseScale) * 20 - 10;
        let ny = y - i * 5;
        vertex(nx, ny);
    }
    endShape();
}

class PixelizedWord {
    constructor(word, x, y, font, fontSize) {
        this.word = word;
        this.x = x;
        this.y = y;
        this.font = font;
        this.fontSize = fontSize;
        this.pixels = [];
        this.pixelSize = 2; // Size of each blocky pixel
        this.createPixelArray();
        this.disappearRate = 0.1; // Adjust the rate of disappearance
        this.disappearance = 0;
    }

    createPixelArray() {
        let pg = createGraphics(width, height);
        pg.pixelDensity(1);
        pg.textFont(this.font);
        pg.textSize(this.fontSize);
        pg.fill(0);
        pg.text(this.word, this.x, this.y);
        pg.loadPixels();

        for (let y = 0; y < pg.height; y += this.pixelSize) {
            for (let x = 0; x < pg.width; x += this.pixelSize) {
                let index = (x + y * pg.width) * 4;
                let r = pg.pixels[index];
                let g = pg.pixels[index + 1];
                let b = pg.pixels[index + 2];
                let a = pg.pixels[index + 3];
                // Only include solid black pixels
                if (a > 128 && r < 128 && g < 128 && b < 128) {
                    let color = { x: x, y: y, r: 0, g: 0, b: 0, a: 255, size: this.pixelSize, falling: false, name: 'black' };
                    this.pixels.push(color);
                }
            }
        }
    }

    update() {
        this.disappearance += this.disappearRate;
        if (this.disappearance >= 1 && this.pixels.length > 0) {
            this.disappearance = 0;
            const randomIndex = floor(random(this.pixels.length));
            this.pixels[randomIndex].falling = true; // Set one pixel to start falling
            let colorIndex = randomIndex % disintegrationColors.length;
            this.pixels[randomIndex].r = disintegrationColors[colorIndex].r;
            this.pixels[randomIndex].g = disintegrationColors[colorIndex].g;
            this.pixels[randomIndex].b = disintegrationColors[colorIndex].b;
            this.pixels[randomIndex].name = disintegrationColors[colorIndex].name;
        }
    }
}
function drawWindows98Frame() {
    let topBarHeight = 40;
    let borderWidth = 10;
    let shadowWidth = 5;
    let title = "type_any_thing.png";

    // Draw the outer frame
    stroke(10);
    fill(200);
    rect(0, 0, width, height);

    // Draw the inner white area
    stroke(10);
    fill(255);
    rect(borderWidth, topBarHeight, width - 2 * borderWidth, height - topBarHeight - borderWidth);

    // Draw the top bar
    fill(180);
    rect(borderWidth, borderWidth, width - 2 * borderWidth, topBarHeight - borderWidth);

    // Draw the title text
    fill(0);
    textSize(16);
    textFont('Arial');
    text(title, width / 2-50, topBarHeight / 2+10);

    // Draw the icons on the top corners
    fill(0);
    rect(borderWidth + 5, borderWidth + 5, 20, 20); // Left icon
    rect(width - borderWidth - 25, borderWidth + 5, 20, 20); // Right icon

    // Draw the shadow effect
    fill(150);
    rect(borderWidth, height - borderWidth - shadowWidth, width - 2 * borderWidth, shadowWidth);
    rect(width - borderWidth - shadowWidth, topBarHeight, shadowWidth, height - topBarHeight - borderWidth);

    // Draw the highlights
    fill(240);
    rect(borderWidth, topBarHeight, width - 2 * borderWidth, 2); // Top highlight
    rect(borderWidth, topBarHeight, 2, height - topBarHeight - borderWidth); // Left highlight
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}